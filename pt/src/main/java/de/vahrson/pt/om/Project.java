package de.vahrson.pt.om;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.torque.TorqueException;
import org.apache.torque.om.Persistent;
import org.apache.torque.util.Criteria;

import de.vahrson.pt.Parameters;
import de.vahrson.util.CollectionUtils;

/**
 * The skeleton for this class was autogenerated by Torque on:
 * 
 * [Wed Feb 04 11:59:44 CET 2004]
 * 
 * You should add additional methods to this class to meet the application
 * requirements. This class will only be generated as long as it does not
 * already exist in the output directory.
 */
public class Project extends de.vahrson.pt.om.BaseProject implements Persistent {
	private static Logger log= Logger.getLogger(Project.class);
	
	public String toString() {
		return "Project: " + getProjectId() + " " + getShortname() + " -- " + getName();
	}
	
	public boolean hasParent() {
		return getParentId() >0;
	}
	
	public boolean hasChildren() throws Exception{
	    return listChildren(getProjectId()).size() >0;
	}

	public static Project getProject(String shortnameOrId) throws TorqueException {
		Project answer= null;
		int id= -1;
		try {
			id= Integer.parseInt(shortnameOrId);
		}
		catch (NumberFormatException nfe) {
			// do nothing
		}

		if (id != -1) {
			answer= BaseProjectPeer.retrieveByPK(id);
		}

		if (answer == null) {
			Criteria query= new Criteria();
			// try short name
			query.add(BaseProjectPeer.SHORTNAME, shortnameOrId);
			List results= BaseProjectPeer.doSelect(query);
			if (results.size() == 1) {
				answer= (Project) results.get(0);
			}
		}

		return answer;
	}
	/**
	 * Answer a list containing the project identified by projectId, 
	 * and all of its parent projects. This project is first, then its parent, 
	 * then its parent's parent, and so on.
	 * @param projectId
	 * @return
	 */
	public static List listProjectHierarchy(int projectId) throws Exception{
		List answer= new ArrayList();
		Project p= ProjectPeer.retrieveByPK(projectId);
		answer.add(p);
		while (p.hasParent()) {
			p= ProjectPeer.retrieveByPK(p.getParentId());
			answer.add(p);
		}
		return answer;
	}
	/**
	 * Answer all hits of the project identified by projectId
	 * @param projectId
	 * @return
	 */
	public static List listHits(int projectId) throws Exception {
		Criteria query= new Criteria();
		query.add(ProjectHitPeer.PROJECT_ID,projectId);
		query.addJoin(ProjectHitPeer.HIT_ID,HitPeer.HIT_ID);
		log.debug(query.toString());
		return HitPeer.doSelect(query);
	}
	
	public List listHits() throws Exception {
		return listHits(getProjectId());
	}

	/**
	 * Answer all primers of the project identified by projectId
	 * @param projectId
	 * @return
	 */
	public static List listPrimers(int projectId) throws Exception {
		Criteria query= new Criteria();
		query.add(ProjectPrimerPeer.PROJECT_ID,projectId);
		query.addJoin(ProjectPrimerPeer.PRIMER_ID,PrimerPeer.PRIMER_ID);
		log.debug(query.toString());
		return PrimerPeer.doSelect(query);
	}
	
	public List listPrimers() throws Exception {
		return listPrimers(getProjectId());
	}

	public static List listOrfs(int projectId) throws Exception {
		Criteria query= new Criteria();
		query.add(ProjectOrfPeer.PROJECT_ID,projectId);
		query.addJoin(ProjectOrfPeer.ORF_ID,OrfPeer.ORF_ID);
		log.debug(query.toString());
		List answer= OrfPeer.doSelect(query);
		if (answer.size()== 0) {
		    Project p= ProjectPeer.retrieveByPK(projectId);
		    if (p.hasParent()) {
		        answer= listOrfs(p.getParentId()); // recursion
		    }
		}
		return answer;
	}
	
	public List listOrfs() throws Exception {
		return listOrfs(getProjectId());
	}
	
	static List listParameters(int projectId) throws Exception {
		Criteria query= new Criteria();
		query.add(ParameterPeer.PROJECT_ID,projectId);
		log.debug(query.toString());
		return ParameterPeer.doSelect(query);
	}
	
	List listParameters() throws Exception {
		return listParameters(getProjectId());
	}
	/**
	 * Answer Parameters for project. If it is a sub-project (i.e. it has parent projects),
	 * load the parents' parameters as well. Parameters set for a sub-project override the
	 * parameters in its parent. 
	 * @param projectId
	 * @return
	 * @throws Exception
	 */
	public static Parameters createParameters(int projectId) throws Exception {
		List parameters= new ArrayList();
		List projects= listProjectHierarchy(projectId);
		Collections.reverse(projects);
		Comparator comp= new Parameter.SameKeyComparator();
		for (Iterator i= projects.iterator(); i.hasNext();) {
			Project p= (Project) i.next();
			List params= listParameters(p.getProjectId());
			for (Iterator k= params.iterator(); k.hasNext();) {
				CollectionUtils.replace(parameters, k.next(), comp );
			}
		}		
		return new Parameters(parameters,Parameter.listDefaultParameters());
	}

	public  Parameters createParameters() throws Exception {
		return createParameters(getProjectId());
	}
	
	/**
	 * Answer a list with all children (i.e., whose parentId=projectId)
	 * @param projectId
	 * @return
	 */
	public static List listChildren(int projectId) throws Exception{
		Criteria query= new Criteria();
		query.add(ProjectPeer.PARENT_ID, projectId);
		return ProjectPeer.doSelect(query);
	}
	
	public  List listChildren() throws Exception{
		return listChildren(getProjectId());
	}
	
	public String getPath() throws Exception{
		StringBuffer answer= new StringBuffer();
		Project parent= getProjectRelatedByParentId();
		if (parent!= null) {
			answer.append(parent.getPath());
			answer.append('/');
		}
		answer.append(getDirectoryPath());
		return answer.toString();
	}
	 
		
	/* (non-Javadoc)
	 * @see de.vahrson.pt.om.BaseProject#getDirectoryPath()
	 */
	public String getDirectoryPath() {
		String answer= super.getDirectoryPath();
		if (answer==null || answer.length()==0) {
			answer= getShortname();
		}
		return answer;
	}
}